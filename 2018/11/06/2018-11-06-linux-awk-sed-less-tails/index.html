<h3 id="直接上代码">直接上代码</h3>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="nb">set time</span> <span class="o">=</span> 12:34:56
<span class="nb">set </span>hr <span class="o">=</span> <span class="sb">`</span><span class="nb">echo</span> <span class="nv">$time</span> | awk <span class="s1">'{split($0,a,":" ); print a[1]}'</span><span class="sb">`</span> <span class="c"># = 12</span>

<span class="nb">set </span>sec <span class="o">=</span> <span class="sb">`</span><span class="nb">echo</span> <span class="nv">$time</span> | awk <span class="s1">'{split($0,a,":" ); print a[3]}'</span><span class="sb">`</span> <span class="c"># = 56</span>

<span class="nb">set </span>hms <span class="o">=</span> <span class="sb">`</span><span class="nb">echo</span> <span class="nv">$time</span> | awk <span class="s1">'{split($0,a,":" ); print a[1], a[2], a[3]}'</span><span class="sb">`</span><span class="c"># = 12 34 56</span>

<span class="c"># 获得5 - 10 line 并且用 `;` 分隔每一行  获得第个元素</span>
sed -n <span class="s1">'5,10p'</span> xvideos.com-db.csv | awk <span class="s1">'{split($0,a,";" ); print a[1]}'</span>

sed -n <span class="s1">'5,10p'</span> xvideos.com-db.csv | awk <span class="s1">'{split($0,a,";" ); print a[1] a[2]}'</span>

<span class="c">#从第3000行开始，显示1000行。即显示3000~3999行</span>
cat filename | tail -n +3000 | head -n 1000

<span class="c">#显示1000行到3000行</span>

cat filename| head -n 3000 | tail -n +1000 

tail -n 1000 <span class="c">#：显示最后1000行</span>

tail -n +1000 <span class="c">#：从1000行开始显示，显示1000行以后的</span>

head -n 1000 <span class="c">#：显示前面1000行</span>

tail -400f demo.log <span class="c">#监控最后400行日志文件的变化 等价与 tail -n 400 -f （-f参数是实时）</span>

less demo.log <span class="c">#查看日志文件，支持上下滚屏，查找功能</span>

uniq -c demo.log  <span class="c">#标记该行重复的数量，不重复值为1</span>

grep <span class="s1">'INFO'</span> demo.log     <span class="c">#在文件demo.log中查找所有包行INFO的行</span>

grep -o <span class="s1">'order-fix.curr_id:\([0-9]\+\)'</span> demo.log    <span class="c">#-o选项只提取order-fix.curr_id:xxx的内容（而不是一整行），并输出到屏幕上</span>
grep -c <span class="s1">'ERROR'</span> demo.log   <span class="c">#输出文件demo.log中查找所有包行ERROR的行的数量</span>

<span class="c"># 输出demo.log中的某个日期中的ERROR的行</span>
sed -n <span class="s1">'/^2011-08-23.*ERROR/p'</span> demolog.log

<span class="c">#指定执行的sed文件</span>
sed -f demo.sed2 demo.log
</code></pre>
</div>
<ul>
  <li>demo.sed2</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="c">#n   #这一行用法和命令中的-n一样意思，就是默认不输出</span>
<span class="c">#demo.sed2</span>
<span class="c">#下面的一行是替换指令，就是把19位长的日期和INFO/ERROR,id,和后面的一截提取出来，然后用@分割符把这4个字段重新按顺序组合</span>
s/^<span class="se">\(</span><span class="o">[</span>-<span class="se">\:</span> 0-9]<span class="se">\{</span>19<span class="se">\}\)</span>.<span class="k">*</span><span class="se">\(</span>INFO<span class="se">\|</span>ERROR<span class="se">\)</span> .<span class="k">*</span>order-fix.curr_id:<span class="se">\(</span><span class="o">[</span>0-9]<span class="se">\+\)</span>,<span class="se">\(</span>.<span class="k">*</span><span class="nv">$\</span><span class="o">)</span>/<span class="se">\1</span>@<span class="se">\3</span>@<span class="se">\2</span>@<span class="se">\4</span>/p


<span class="c">#排序功能 -t表示用@作为分割符，-k表示用分割出来的第几个域排序(不要漏掉后面的,2/,3/,1，详细意思看下面的参考链接，这里不做详述)</span>
sed -f test.sed demolog.log | sort -t@ -k2,2n -k3,3r -k1,1  <span class="c">#n为按数字排序，r为倒序</span>


awk <span class="s1">'BEGIN{FS="@"} {print $2,$3}'</span> demo.log_after_sort   <span class="c">#BEGIN中预处理的是，把@号作为行的列分割符,把分割后的行的第2，3列输出</span>

</code></pre>
</div>

<ul>
  <li>对指定时间范围内的日志进行统计，包括输出INFO，ERROR总数，记录总数，每个订单记录分类统计</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sed -f demo.sed demolog.log | sort -t@ -k2,2n -k3,3r -k1,1 | awk -f demo.awk
</code></pre>
</div>

<ul>
  <li>demo.awk</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="c">#下面的例子是作为命令行输入的，利用单引号作为换行标记，这样就不用另外把脚本写进文件调用了</span>
awk <span class="s1">'
BEGIN {
  FS="@"
}
 
{
  if ($3 == "INFO") {info_count++}
  if ($3 == "ERROR") {error_count++}
 
}
 
END {
  print "order total count:"NR           #NR是awk内置变量，是遍历的当前行号，到了END区域自然行号就等于总数了
  printf("INFO count:%d ERROR count:%d\n",info_count,error_count)
} '</span> demo.log_after_sort

</code></pre>
</div>

<p>原文：https://blog.csdn.net/UltraNi/article/details/6750434</p>

<p>转载请注明出处，本文采用 <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">CC4.0</a> 协议授权</p>
